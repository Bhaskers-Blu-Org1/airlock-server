package com.ibm.airlock.admin.translations;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Logger;

import javax.servlet.ServletContext;

import org.apache.wink.json4j.JSONArray;
import org.apache.wink.json4j.JSONException;
import org.apache.wink.json4j.JSONObject;

import com.ibm.airlock.AirLockContextListener;
import com.ibm.airlock.Constants;
import com.ibm.airlock.Constants.IssueStatus;
import com.ibm.airlock.Constants.Stage;
import com.ibm.airlock.Constants.StringStatus;
import com.ibm.airlock.Constants.TranslationStatus;
import com.ibm.airlock.admin.Product;
import com.ibm.airlock.admin.Season;
import com.ibm.airlock.admin.Utilities;
import com.ibm.airlock.admin.Utilities.ProductErrorPair;
import com.ibm.airlock.admin.operations.AirlockChange;
import com.ibm.airlock.admin.operations.Webhooks;
import com.ibm.airlock.admin.serialize.AirlockFilesWriter;
import com.ibm.airlock.admin.serialize.TranslatorLogWriter;
import com.ibm.airlock.admin.translations.OriginalString.StringTranslations.LocaleTranslationData;
import com.ibm.airlock.engine.Version;

public class BackgroundTranslator
{
	static final Logger logger = Logger.getLogger(BackgroundTranslator.class.getName());
	static final int smartlingBatch = 100;

	Date lastTranslated = new Date();
	Date lastRetranslated = new Date();
	boolean needTranslations = false;
	boolean needRetranslations = false;

	ServletContext context;
	SmartlingClient client;
	Map<String, Product> productsDB;
	Map<String, Season> seasonsDB;
	Set<String> seasonLocales, smartlingLocales, modifiedLocales, productionLocales;
	//Map<String,Map<String,List<String>>> sourceIssues; // pull issues generated by Smartling
	Map<String,SmartlingClient.ProjectIssues> allIssues; // pull all issues from Smartling
	TranslatorLogWriter smartlingLogger;
	ReentrantReadWriteLock lock;
	String smartlingProject;
	volatile boolean running;
	volatile boolean wakeup;

	int stringSleep; // how many seconds to sleep before looking for new strings
	int afterStringPause; // how many seconds to pause before looking for a new string's translation
	int translationSleep; // how many seconds to sleep before looking for new translations
	int retranslationSleep; // how many seconds to sleep before looking for replaced translations

	Thread thread;
	SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ"); // not multiThreaded
	String seasonId = "";

	//-----------------------------------------------------------------------
	// temporary classes to prevent resource locking while accessing Smartling API
	static class TranslationState
	{
	//	String localeId;
		String translation;
		String previousTranslation;
		String newTranslationAvailable;
	//	Date modifiedDate;
	}

	static class StringState
	{
		enum Cycle { NOT_TRANSLATED, PARTIALLY_TRANSLATED, TRANSLATED };
		Cycle cycle = Cycle.NOT_TRANSLATED;

		String hash; // Smartling hash
		String text;
		String variant;
		String instruction;
		Date created;
		String createProcessId; // once created it's set to null && you can start translating
		boolean overwritten;
		TreeMap<String, TranslationState> translations = new TreeMap<String, TranslationState>(); // indexed by locale

		StringState() {}
		StringState(String text, String variant, String hash, String instruction, boolean overwritten)
		{
			this.text = text;
			this.variant = variant;
			this.hash = hash;
			this.instruction = instruction;
			this.overwritten = overwritten;
		}

		static void arrayFromJSON(JSONObject json, String processId, ArrayList<StringState> out) throws JSONException
		{
			JSONArray items = json.getJSONArray("items");
			for (int i = 0; i < items.length(); ++i)
			{
				JSONObject item = items.getJSONObject(i);
				StringState state = stringFromJSON(item, processId);
				state.created = new Date();
				out.add(state);
			}
		}
		static StringState stringFromJSON(JSONObject json, String processId) throws JSONException
		{
			String text = json.getString("stringText");
			String hash = json.getString("hashcode");
			String variant = json.optString("variant");
			boolean overWritten = json.getBoolean("overWritten");
			String instruction = json.optString("instruction");

			StringState str = new StringState(text, variant, hash, instruction, overWritten);
			str.createProcessId = processId; // null if creation is complete
			return str;
		}

		static JSONObject toJSON(StringState str) throws JSONException
		{
			JSONObject obj = new JSONObject();
			obj.put("stringText", str.text);
			obj.put("format","plain_text");
			// hash is ignored, we want it recalculated

			if (str.variant != null)
				obj.put("variant", str.variant);
			if (str.instruction != null)
				obj.put("instruction", str.instruction);
			return obj;
		}
		static JSONObject toJSON(ArrayList<StringState> toCreate, int from, int to) throws JSONException
		{
			if (to > toCreate.size())
				to = toCreate.size();

			JSONArray array = new JSONArray();;
			for (int i = from; i < to; ++i)
			{
				StringState state = toCreate.get(i);
				array.add(toJSON(state));
			}

			JSONObject json = new JSONObject();
			json.put("strings", array);
			json.put("placeholderFormat", "none");
			json.put("placeholderFormatCustom", Constants.SMARTLING_PLACEHOLDER_FORMAT);
			return json;
		}
	}
	//-----------------------------------------------------------------------
	class Background implements Runnable
	{
		@Override
		public void run() 
		{
			while (running)
			{
				try {
					Thread.sleep(stringSleep * 1000);
				}
				catch (InterruptedException e)
				{
					continue; // check if still running
				} 

				try {
					runTask();
				}
				catch (Exception e)
				{
					logger.severe(e.toString());
					smartlingLogger.log("Exception : " + e.toString());
					continue;
				}
			}
		}
	}

	//-----------------------------------------------------------------------
	@SuppressWarnings("unchecked")
	public BackgroundTranslator(SmartlingClient client, ServletContext context, TranslatorLogWriter smartlingLogger)
	{
		this.client = client;
		this.context = context;
		this.smartlingLogger = smartlingLogger;

		// stringData is season-dependent, so loop on all seasons.
		// the lock is a global one locking all season instances
		this.seasonsDB = (Map<String, Season>) context.getAttribute(Constants.SEASONS_DB_PARAM_NAME);
		this.productsDB = (Map<String, Product>)context.getAttribute(Constants.PRODUCTS_DB_PARAM_NAME);
		this.lock = (ReentrantReadWriteLock) context.getAttribute(Constants.GLOBAL_LOCK_PARAM_NAME);

		setTimers();
		this.wakeup = false;
		this.running = false;
		this.thread = new Thread(new Background());
	}

	void setTimers()
	{
		String srcPause = AirLockContextListener.getEnv(Constants.ENV_TRANSLATOR_NEW_STRING_PAUSE);
		String tgtPause = AirLockContextListener.getEnv(Constants.ENV_TRANSLATION_PAUSE);
		String retPause = AirLockContextListener.getEnv(Constants.ENV_RETRANSLATION_PAUSE);

		stringSleep = translationSleep = retranslationSleep = 0;
		try { stringSleep = Integer.parseInt(srcPause); }
		catch (Exception e)	{}
		try { translationSleep = Integer.parseInt(tgtPause); }
		catch (Exception e)	{}
		try { retranslationSleep = Integer.parseInt(retPause); }
		catch (Exception e)	{}

		if (stringSleep <= 0)
			stringSleep = Constants.TRANSLATOR_NEW_STRING_DEFAULT;
		if (translationSleep <= 0)
			translationSleep = Constants.ENV_TRANSLATION_PAUSE_DEFAULT;
		if (retranslationSleep <= 0)
			retranslationSleep = Constants.ENV_RETRANSLATION_PAUSE_DEFAULT;

		afterStringPause = Constants.TRANSLATOR_WAIT_AFTER_NEW_STRING;
	}
	public void start()
	{
		smartlingLogger.log("Smartling background thread started");
		running = true;
		thread.start();
	}
	public void stop() throws InterruptedException
	{
		running = false;
		thread.interrupt();
		thread.join();
		smartlingLogger.log("Smartling background thread stopped");
		smartlingLogger.close();
	}
	public void wakeup() // for testing - wakes up string/translation/re-translation processing
	{
		wakeup = true;
		smartlingLogger.log("waking up thread");
		thread.interrupt();
	}

	public void setFine(boolean on)
	{
		smartlingLogger.setFine(on);
	}
	public void setTrace(boolean on)
	{
		smartlingLogger.setTrace(on);
	}
	public ArrayList<String> getTrace()
	{
		return smartlingLogger.getTrace();
	}
	public void log(String msg)
	{
		smartlingLogger.log(seasonId + msg);
	}
	public void fine(String msg)
	{
		if (smartlingLogger.isFine())
			smartlingLogger.fine(seasonId + msg);
	}

	// can be called from other threads
	public Set<String> getSmartlingLocales(String projectId) throws Exception
	{
		return client.getProjectLocaleSet(projectId);
	}
	// can be called from other threads
	public Set<String> seasonLocales2SmartlingLocales(Set<String> in)
	{
		Set<String> out = new TreeSet<String>();
		for (String str : in)
		{
			String localeId = SmartlingLocales.get(str);
			if (localeId != null)
				out.add(localeId);
		}
		return out;
	}

	void runTask() throws Exception
	{
		seasonId = "";
		smartlingLogger.log("Background task started");

		// make a private shallow copy of seasons to avoid locking up the services.
		// re-lock when accessing each season.
		// in all tasks, always release common data lock before attempting to use the Smartling api.
		ArrayList<Season> allSeasons = new ArrayList<Season>();
		try {
			lock.readLock().lock();
			for (Season season : seasonsDB.values())
			{
				Version ver = Version.find(season.getServerVersion());
				if (ver.i >= Version.v2_5.i)
					allSeasons.add(season);
			}
		} finally {
			lock.readLock().unlock();
		}

		Date now = new Date();
		if (wakeup)
		{
			needTranslations = needRetranslations = true;
			wakeup = false;
		}
		else
		{
			needTranslations = ((now.getTime() - lastTranslated.getTime()) / 1000 > translationSleep);
			needRetranslations = ((now.getTime() - lastRetranslated.getTime()) / 1000 > retranslationSleep);
		}

		//sourceIssues = new TreeMap<String,Map<String,List<String>>>();
		allIssues = new TreeMap<String,SmartlingClient.ProjectIssues>();

		for (Season season : allSeasons)
		{
			String str = season.getUniqueId().toString();
			smartlingLogger.log("checking season " + str);

			seasonId = "[season " + str + "] ";
			doSeason(season);
			seasonId = "";

			if (!running)
				return;
		}

		if (needTranslations)
			lastTranslated = new Date();
		if (needRetranslations)
			lastRetranslated = new Date();
	}

	void doSeason(Season season) throws Exception
	{
		OriginalStrings stringData = null;
		try {
			lock.readLock().lock();
			// a purged season will have empty stringData
			stringData = season.getOriginalStrings();
			seasonLocales = new TreeSet<String>(stringData.getSupportedLanguages());
			smartlingProject = getSmartlingProject(season);
		} finally {
			lock.readLock().unlock();
		}

		if (smartlingProject == null)
		{
			log("not configured with Smartling");
			return;
		}
		client.setProject(smartlingProject);

		modifiedLocales = new TreeSet<String>();
		productionLocales = new TreeSet<String>();

		boolean found = checkForNewStrings(stringData);
		if (running)
		{
			if (found) // if new strings are added, always check for their translation, but wait a bit first.
			{
				try {
					Thread.sleep(afterStringPause * 1000);
					checkForNewTranslations(stringData);
				}
				catch (InterruptedException e) {} 
			}
			else if (needTranslations) // no new strings, but it's time to check for missing translations on old strings
				checkForNewTranslations(stringData);
		}

		if (running && needRetranslations)
		{
			checkForRetranslations(stringData);
			//checkForSourceIssues(stringData);
			checkForIssues(stringData);
		}
		AirlockChange change = new AirlockChange();
		change.setSeason(season);
		ProductErrorPair productErrorPair = Utilities.getProductOfBranchOrSeason(context, null, season.getUniqueId().toString());
		change.setProduct(productErrorPair.product);
		
		for (String locale : modifiedLocales)
		{
			// free the lock periodically to avoid blocking the server
			try {
				lock.writeLock().lock();
				if (!season.isPurged()) // the season may have been purged by other threads when the lock was released
				{
					if (locale.equals(Constants.DEFAULT_LANGUAGE))
					{
						log("saving original strings");
						boolean writeProduction = productionLocales.contains(locale);
						change.getFiles().addAll(AirlockFilesWriter.writeOriginalStrings(season, context, writeProduction? Stage.PRODUCTION: Stage.DEVELOPMENT));
					}
					else
					{
						log("saving translations for " + locale);
						boolean writeProduction = productionLocales.contains(locale);
						change.getFiles().addAll(AirlockFilesWriter.writeLocaleStringsFiles(season, locale, context, writeProduction));
					}
				}
			}
			finally {
				lock.writeLock().unlock();
			}
		}
		if (!change.getFiles().isEmpty()) {
			Webhooks.get(context).notifyChanges(change, context);
		}
	}

	boolean checkForNewStrings(OriginalStrings stringData) throws Exception
	{
		boolean found = false;

		// scan strings table for strings awaiting creation
		//-------------------------------------------------
		ArrayList<StringState> toCreate = new ArrayList<StringState>();
		try {
			lock.readLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				if (!running)
					break;

				// manually modified strings sometimes miss the hash. treat them as new strings
				StringStatus status = orig.getStatus();
				if (status == StringStatus.REVIEWED_FOR_TRANSLATION || (status == StringStatus.IN_TRANSLATION && getHash(orig) == null))
				{
					StringState state = new StringState();
					state.text = orig.getValue();
					state.variant = orig.getVariant();

					state.instruction = "Key: '" + orig.getKey() + "'. "; // add the airlock key to the instruction to provide context

					// temporary code until max size can be passed in a separate field
					Integer maxsz = orig.getMaxStringSize();
					if (maxsz != null)
						state.instruction += "Maximum string size: " + maxsz + ". ";

					state.instruction += orig.getTranslationInstruction();

					toCreate.add(state);
				}
			}
		}
		finally {
			lock.readLock().unlock();
		}

		log(toCreate.size() + " new strings found");
		if (!running || toCreate.isEmpty())
			return found;

		// add these strings to the smartling project in chunks of 100
		//------------------------------------------------------------
		ArrayList<StringState> arr = new ArrayList<StringState>();
		for (int i = 0; i < toCreate.size(); i += smartlingBatch)
		{
			sendChunk(toCreate, arr, i);
		}
		found = arr.size() > 0;

		log(arr.size() + " smartling hashes returned");
		if (!running || arr.isEmpty())
			return found;

		// index items by text+variant, for quick reference.
		TreeMap<String, StringState> index = new TreeMap<String, StringState>();
		for (StringState state : arr)
		{
			String key = qualifiedText(state.text, state.variant);
			index.put(key, state);

			String type = state.overwritten ? "old" : "new";
			log(type + " string: " + printText(state));
		}

		if (!running)
			return found;

		// populate strings table with smartling hashes
		//---------------------------------------------
		int finished = 0;
		int inProcess = 0;
		try {
			lock.writeLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				String key = qualifiedText(orig.getValue(), orig.getVariant());
				StringState state = index.get(key);
				if (state == null)
					continue; // string was just added by another thread - skip for now

				orig.setTranslatorId(state.hash);
				orig.setStatus(StringStatus.IN_TRANSLATION);
				if (state.createProcessId != null)
				{
					orig.setSmartlingCreationProcess(state.createProcessId); // mark: extra check needed before starting to translate
					++inProcess;
				}

				modifiedLocales.add(Constants.DEFAULT_LANGUAGE); // indicate rewrite of source file
				++finished;
			}
		}
		finally {
			lock.writeLock().unlock();
		}

		log((finished - inProcess) + " strings created in Smartling, " + inProcess + " still being processed");
		return found;
	}

	void sendChunk(ArrayList<StringState> in, ArrayList<StringState> out, int index) throws Exception
	{
		JSONObject json = StringState.toJSON(in, index, index + smartlingBatch);
		SmartlingClient.RestCallResults result = client.createStrings(json);
		if (result.code != 200 && result.code != 202)
			throw new Exception("createStrings code " + result.code + ": " + result.message);

		// it should be OK to exit here. if we resend the same strings later, the same hashes will return
		if (!running)
			return;

		// hashes are always generated, even if the strings were not actually created in smartling.
		// if creation is pending keep the process id and check on it later
		boolean notCreated = (result.code == 202);
		JSONObject res = client.parseResult(result);

		res = res.getJSONObject("data");
		// processId  will be used to check creation status later
		String processId = notCreated ? json.getString("processUid") : null;
		StringState.arrayFromJSON(res, processId, out);
		if (notCreated)
			log("String creation is not finished. Smartling process ID is " + processId);
	}

	String qualifiedText(String text, String variant) // TODO may need a name-space too
	{
		if (variant == null)
			variant = ""; // need this normalization because both options appear in the data
		return text + "_" + variant;
	}
	String printText(StringState state)
	{
		String var = (state.variant == null) ? "" : state.variant;
		return "[" + state.hash + "] [" + var + "] [" + state.text + "]";
	}
	String getHash(OriginalString orig)
	{
		String hash = orig.getTranslatorId();
		if (hash == null)
			return "";
		return hash;
	}
	String getSmartlingProject(Season season) // runs inside read lock
	{
		String id = season.getProductId().toString();
		Product product = productsDB.get(id);
		return (id == null) ? null : product.getSmartlingProjectId();
	}
	// check status of new strings whose acceptance process was incomplete 
	TreeMap<String,Integer> checkProcessIds(OriginalStrings stringData) throws Exception
	{
		TreeSet<String> procIds = new TreeSet<String>();
		try {
			lock.readLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				if (!running)
					break;

				if (orig.getStatus() != StringStatus.IN_TRANSLATION)
					continue;

				String createProcessId = orig.getSmartlingCreationProcess();
				if (createProcessId != null)
					procIds.add(createProcessId);
			}
		}
		finally {
			lock.readLock().unlock();
		}

		TreeMap<String,Integer> verifiedProcess = new TreeMap<String,Integer>();
		for (String id : procIds)
		{
			if (!running)
				break;

			Integer status = checkCreationStatus(id);
			verifiedProcess.put(id, status);
			log("checked process Id  " + id + ", status is " + status);
		}
		return verifiedProcess;
	}

	void checkForNewTranslations(OriginalStrings stringData) throws Exception
	{
		// scan strings table for strings awaiting translation
		//----------------------------------------------------
		ArrayList<StringState> toTranslate = new ArrayList<StringState>();
		TreeMap<String,Integer> verifiedProcess = checkProcessIds(stringData);
		int inProcess = 0;

		try {
			lock.readLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				if (!running)
					break;
	
				// look for strings awaiting translation that have an established hash
				if (orig.getStatus() != StringStatus.IN_TRANSLATION || getHash(orig).isEmpty())
					continue;

				String createProcessId = orig.getSmartlingCreationProcess();
				if (createProcessId != null)
				{
					Integer status = verifiedProcess.get(createProcessId);
					if (status == null)
						continue; // just in case - shouldn't happen. handle in next round

					if (status < 1)
					{
						++inProcess;
						if (status < 0) 
						{
							String msg = "string '" + orig.getValue() + "' could not be created in Smartling";
							logger.warning(msg);
							log(msg);
						}
						continue;
					}
					else
					{
						orig.setSmartlingCreationProcess(null); // no need to check this again
						modifiedLocales.add(Constants.DEFAULT_LANGUAGE); // mark original string table as updated
					}
				}

				StringState state = new StringState();
				Map<String,LocaleTranslationData> translatedLocales = orig.getStringTranslations().getStringTranslationsMap();

				for (String locale : seasonLocales)
				{
					if (locale.equals(Constants.DEFAULT_LANGUAGE))
						continue;

					LocaleTranslationData data = translatedLocales.get(locale);
					if (data == null || data.getTranslationStatus() == TranslationStatus.NOT_TRANSLATED)
					{
						state.translations.put(locale, new TranslationState()); // this locale still needs translating
					}
				}
				if (state.translations.size() > 0)
				{
					state.hash = getHash(orig);
					state.text = orig.getValue();
					//state.id = orig.getUniqueId();
					state.variant = orig.getVariant();
					toTranslate.add(state);
				}
			}
		}
		finally {
			lock.readLock().unlock();
		}

		log(toTranslate.size() + " strings to translate found, " + inProcess + " still awaiting creation");
		if (!running || toTranslate.isEmpty())
			return;

		// get smartling translations for these strings
		//---------------------------------------------
		getSmartlingTranslations(toTranslate, true);

		// index items by hash, for quick reference.
		TreeMap<String, StringState> index = new TreeMap<String, StringState>();
		for (StringState state : toTranslate)
		{
			index.put(state.hash, state);
		}

		int full = 0;
		int changed = 0;
		// populate strings table with the results
		//----------------------------------------
		try {
			lock.writeLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				String hash = getHash(orig);
				StringState state = index.get(hash);
				if (state == null)
					continue;  // string was just added by another thread - skip for now

				if (state.cycle == StringState.Cycle.NOT_TRANSLATED)
					continue; // not modified in this round
	
				++changed;
				boolean inProduction = orig.getStage().equals(Stage.PRODUCTION);
	
				for (Map.Entry<String,TranslationState> ent : state.translations.entrySet())
				{
					String locale = ent.getKey();
					TranslationState ts = ent.getValue();
					if (ts == null)
						continue; // no translation for this locale

					orig.addStringTranslationForLocale(locale, ts.translation, stringData.getSupportedLanguages());
					// indicate rewrite of target file
					modifiedLocales.add(locale);
					if (inProduction)
						productionLocales.add(locale);
				}
	
				if (state.cycle == StringState.Cycle.TRANSLATED)
				{
					++full;
					// status change is not really needed because the last addStringTranslationForLocale() updates it
					orig.setStatus(StringStatus.TRANSLATION_COMPLETE); // otherwise still IN_TRANSLATION
					modifiedLocales.add(Constants.DEFAULT_LANGUAGE); // indicate rewrite of source file

				}
			}
		}
		finally {
			lock.writeLock().unlock();
		}

		log(changed + " strings have new translations, " + full + " of them are fully translated");
	}

	void getSmartlingTranslations(ArrayList<StringState> toTranslate, boolean firstTranslation) throws Exception
	{
		smartlingLocales = client.getProjectLocaleSet(null);
		for (StringState state : toTranslate)
		{
			if (!running)
				return;

			if (firstTranslation)
			{
				Set<String> locales = state.translations.keySet();
				log("seeking new translations for: " + 	printText(state));
				log("missing translations: " + 	locales);
			}

			int needTranslations = state.translations.size();
			int translated = 0;

			for (Map.Entry<String,TranslationState> ent : state.translations.entrySet())
			{
				String locale = ent.getKey();
				TranslationState ts = ent.getValue();

				String localeId = SmartlingLocales.get(locale); // convert to Smartling locale ID
				if (localeId == null)
				{
					if (firstTranslation)
						log("locale '" + locale + "' is not mapped to a smartling locale Id");
					continue;
				}
				if (!smartlingLocales.contains(localeId))
				{
					if (firstTranslation)
						log("needed locale is not configured in smartling project: " +  locale + " (" + localeId + ")");
					continue;
				}

				// what to do with REST error - set special state?
				JSONObject json = client.getOneStringTranslations( state.hash, "targetLocaleId=" + localeId);
				JSONObject data = json.getJSONObject("data");
				JSONArray array = data.getJSONArray("items");
				for (int i = 0; i < array.length(); ++i)
				{
					JSONObject result = array.getJSONObject(i);
					JSONArray translations = result.optJSONArray("translations");
					if (translations == null || translations.isEmpty())
						continue;

					// for now assume just one translation
					JSONObject translation = translations.getJSONObject(0);
					ts.translation = translation.getString("translation");
					++translated;

					//String date = translation.getString("modifiedDate");
					// t.modifiedDate = Date.from( Instant.parse(date) ); // Java 8, not supported everywhere
					// t.modifiedDate = formatter.parse(date); doesn't work on Z
					//date = date.replace("Z", "-0000");
					//ts.modifiedDate = formatter.parse(date);
					//ts.localeId = locale;
					//state.translations.put(locale, ts);

					if (firstTranslation)
						log("string " + printText(state) + ", locale " + locale + ", translation: " + ts.translation);
				 }
			 }

			 if (firstTranslation && translated > 0)
			 {
				 state.cycle = (translated == needTranslations) ? StringState.Cycle.TRANSLATED : StringState.Cycle.PARTIALLY_TRANSLATED;
			 }
		}
	}

	// (should run once a day)
	// seek new translations for strings that have already been translated
	void checkForRetranslations(OriginalStrings stringData) throws Exception
	{
		ArrayList<StringState> toRetranslate = new ArrayList<StringState>();

		try {
			lock.readLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				if (!running)
					break;
	
				if (getHash(orig).isEmpty() || orig.getSmartlingCreationProcess() != null) // string creation incomplete, skip it
					continue;

				StringStatus status = orig.getStatus();
				if (status != StringStatus.IN_TRANSLATION && status != StringStatus.TRANSLATION_COMPLETE)
					continue;

				StringState state = new StringState();
				Map<String,LocaleTranslationData> translatedLocales = orig.getStringTranslations().getStringTranslationsMap();

				for (String locale : seasonLocales)
				{
					if (locale.equals(Constants.DEFAULT_LANGUAGE))
						continue;

					LocaleTranslationData data = translatedLocales.get(locale);
					if (data == null || data.getTranslationStatus() == TranslationStatus.NOT_TRANSLATED)
					{}
					else
					{
						TranslationState ts = new TranslationState();
						ts.previousTranslation = data.getTranslatedValue();
						ts.newTranslationAvailable = data.getNewTranslationAvailable();
						state.translations.put(locale, ts);
					}
				}
				if (state.translations.size() > 0)
				{
					state.hash = getHash(orig);
					state.text = orig.getValue();
					state.variant = orig.getVariant();
					toRetranslate.add(state);
				}
			}
		}
		finally {
			lock.readLock().unlock();
		}

		if (!running || toRetranslate.isEmpty())
			return;

		// get retranslations for these strings
		//-------------------------------------
		getSmartlingTranslations(toRetranslate, false);

		// prune unchanged items and index items by hash for quick reference
		//------------------------------------------------------------------
		TreeMap<String, StringState> index = new TreeMap<String, StringState>();
		for (StringState state : toRetranslate)
		{
			TreeMap<String, TranslationState> pruned = null;
			for (Map.Entry<String, TranslationState> ent : state.translations.entrySet())
			{
				String locale = ent.getKey();
				TranslationState ts = ent.getValue();
				String compareTo = (ts.newTranslationAvailable != null) ? ts.newTranslationAvailable : ts.previousTranslation;
				if (ts.translation != null && !ts.translation.equals(compareTo))
				{
					if (pruned == null)
						pruned = new TreeMap<String, TranslationState>();
					pruned.put(locale, ts);
				}
			}
			if (pruned != null)
			{
				state.translations = pruned;
				index.put(state.hash, state);
			}
		}

		// populate strings table with the results
		//----------------------------------------
		try {
			lock.writeLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				String hash = getHash(orig);
				StringState state = index.get(hash);
				if (state == null)
					continue;  // no changes found for it yet


				boolean inProduction = orig.getStage().equals(Stage.PRODUCTION);
				Map<String, LocaleTranslationData> tmap = orig.getStringTranslations().getStringTranslationsMap();
	
				for (Map.Entry<String,TranslationState> ent : state.translations.entrySet())
				{
					String locale = ent.getKey();
					TranslationState ts = ent.getValue();

					LocaleTranslationData ltd = tmap.get(locale);
					if (ltd == null)
						continue;

					ltd.setNewTranslationAvailable(ts.translation);
					log("retranslation available for " + printText(state) + ", locale " + locale + ", old: " + ts.previousTranslation + ", new: " + ts.translation);

					// indicate rewrite of target file
					modifiedLocales.add(locale);
					if (inProduction)
						productionLocales.add(locale);
				}
			}
		}
		finally {
			lock.writeLock().unlock();
		}
	}

	// (should run once a day)
	// pull Smartling-generated issues
	void checkForIssues(OriginalStrings stringData) throws Exception
	{
		SmartlingClient.ProjectIssues projectIssues = allIssues.get(smartlingProject);
		if (projectIssues == null)
		{
			projectIssues = client.getAllIssueStatus(smartlingProject); // pull it just once per project
			allIssues.put(smartlingProject, projectIssues);
		}
		if (projectIssues.isEmpty())
			return;
		
		try {
			lock.writeLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				checkOneIssue(projectIssues, orig);
			}
		}
		finally {
			lock.writeLock().unlock();
		}
	}
	
	void checkOneIssue(SmartlingClient.ProjectIssues projectIssues, OriginalString orig)
	{
		String hash = getHash(orig);
		Map<String,IssueStatus> issueMap = projectIssues.get(hash); // indexed by Smartling locales
		if (issueMap == null)
			return;

		IssueStatus oldStat = orig.getIssueStatus();
		IssueStatus newStat = issueMap.get("en-US");
		if (oldStat != newStat)
		{
			orig.setIssueStatus(newStat);
			modifiedLocales.add(Constants.DEFAULT_LANGUAGE);
		}

		boolean inProduction = orig.getStage().equals(Stage.PRODUCTION);
		for (Map.Entry<String, LocaleTranslationData> ent : orig.getStringTranslations().getStringTranslationsMap().entrySet())
		{
			String locale = ent.getKey();
			LocaleTranslationData data = ent.getValue();
			String smartlingLocale = SmartlingLocales.get(locale);
			if (smartlingLocale == null)
				continue;

			oldStat = data.getIssueStatus();
			newStat = issueMap.get(smartlingLocale);
			if (oldStat != newStat)
			{
				data.setIssueStatus(newStat);
				modifiedLocales.add(locale);
				if (inProduction)
					productionLocales.add(locale);
			}
		}
	}
/*
	void checkForSourceIssues(OriginalStrings stringData) throws Exception
	{
		Map<String,List<String>> projectSourceIssues = sourceIssues.get(smartlingProject);
		if (projectSourceIssues == null)
		{
			projectSourceIssues = client.getSourceIssues(smartlingProject); // pull it just once per project
			sourceIssues.put(smartlingProject, projectSourceIssues);
		}
		if (projectSourceIssues.isEmpty())
			return;

		try {
			lock.writeLock().lock();
			for (OriginalString orig : stringData.getOrigStringsList())
			{
				checkOneSourceIssue(projectSourceIssues, orig);
			}
		}
		finally {
			lock.writeLock().unlock();
		}
	}
	void checkOneSourceIssue(Map<String,List<String>> seasonSourceIssues, OriginalString orig)
	{
		String hash = getHash(orig);
		List<String> newIssues = seasonSourceIssues.get(hash);
		if (newIssues == null)
			return;

		boolean changed = false;
		Issues oldIssues = orig.getIssueIds();
		if (oldIssues == null)
		{
			orig.setIssueIds(new Issues(newIssues));
			changed = true;
		}
		else
		{
			int oldSz = oldIssues.issues.size();
			for (String str : newIssues)
				oldIssues.add(str);
			int newSz = oldIssues.issues.size();
			changed = (newSz > oldSz);
		}

		if (changed)
			modifiedLocales.add(Constants.DEFAULT_LANGUAGE);
	}
*/
	// 1 OK, 0 pending, -1 error
	int checkCreationStatus(String createProcessId) throws Exception
	{
		 JSONObject json = client.checkCreateStringsStatus(createProcessId);
		 JSONObject data = json.getJSONObject("data");
		 String state = data.getString("processState");

		 if (state.equals("FAILED"))
			 return -1;

		 // documentation says "CLOSED" but we get "COMPLETED"
		 if (state.equals("CLOSED") || state.equals("COMPLETED"))
			 return 1;


		 return 0; // not created yet in smartling, leave it for later 
	 }


	public String createIssue(String project, JSONObject body) throws Exception
	{
		return client.createIssue(project, body);
	}

	public JSONObject getIssue(String project, String issueUid) throws Exception
	{
		// merge comments into output
		JSONObject obj = client.getIssue(project, issueUid);
		JSONObject comments = client.getIssueComments(project, issueUid);
		JSONArray items = comments.getJSONArray("items");
		obj.put("items", items);
		return obj;
	}
	public JSONObject getStringIssues(String project, String smartlingHash, String locale) throws Exception
	{
		return client.getStringIssues(project, smartlingHash, locale);
	}
	public String getIssueStatus(String project, String smartlingHash, String locale) throws Exception
	{
		return client.getIssueStatus(project, smartlingHash, locale);
	}
	public void updateIssue(String project, String issueUid, String body) throws Exception
	{
		boolean ok = false;
		JSONObject json = new JSONObject(body);

		if (json.containsKey("setOpenStatus"))
		{
			Boolean setOpenStatus = json.optBoolean("setOpenStatus");
			if (setOpenStatus != null)
			{
				boolean close = !setOpenStatus;
				client.closeOrReopenIssue(project, issueUid, close);
				ok = true;
			}
		}

		String comment = json.optString("comment");
		if (comment != null)
		{
			@SuppressWarnings("unused")
			String commentId = client.createIssueComment(project, issueUid, comment);
			ok = true;
		}

		String text = json.optString("issueText");
		if (text != null)
		{
			client.editIssueText(project, issueUid, text);
			ok = true;
		}

		if (!ok)
			throw new Exception("'update issue' has no instructions");
	}
}

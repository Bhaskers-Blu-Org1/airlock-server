package com.ibm.airlock.admin;

import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

import org.apache.wink.json4j.JSONException;
import org.apache.wink.json4j.JSONObject;
import org.mozilla.javascript.Context;
import org.mozilla.javascript.Function;
import org.mozilla.javascript.Scriptable;
import org.mozilla.javascript.ScriptableObject;

import com.ibm.airlock.Constants;
import com.ibm.airlock.Constants.InputSampleGenerationMode;
import com.ibm.airlock.engine.SafeContextFactory;

public class JsonGenerator
{
	//---------------------------------------------------------------------------
	// simple generation
	public static String generation(String generatorScript, String jsfScript, String schema) throws GenerationException
	{
        new SafeContextFactory().makeContext();
        Context rhino = Context.enter();

		// it's set because of the problem:
		// Encountered code generation error while compiling script: generated bytecode for method exceeds 64K limit.
        rhino.setOptimizationLevel(-1);

        try {
        	Scriptable scope = rhino.initStandardObjects();
			rhino.evaluateString(scope, generatorScript, "<generator>", 1, null);
			rhino.evaluateString(scope, jsfScript, "<jsf>", 1, null);

			Function generateFunction = (Function)scope.get("simpleGenerate", scope);
			Object generateArgs[]= {  schema };
			String sampleStr = (String)generateFunction.call(rhino, scope, scope, generateArgs);

			// transformation for pretty-printing & remove generated id
			JSONObject json = new JSONObject(sampleStr);
			json.remove(Constants.JSON_FIELD_GENERATED_ID);
			return json.write(true);
        }
        catch (Throwable e){
        	throw new GenerationException(e.getMessage());
        }
        finally {
        	Context.exit();
        }
	}

	//--------------------------------------------------------------------------------
	// prune schema by stage/version, then generate

	// mode parameter: determines which fields are generated.
	// generate JSON with minimal fields, maximal fields, or select the optional fields at random

	// randomizer parameter: determines which field values are generated.
	// set to -1 if true randomization of values is required (uses the original Math.random)
	// otherwise it is a constant in the range [0,1) that will always be used instead of a 
	// random number when generating values, producing deterministic results in the JSON faker.

	public static String generation(String generatorScript, String jsfScript, String pruneScript,
			String schema, String stage, String minAppVer, InputSampleGenerationMode mode, double randomizer) throws GenerationException
	{
    	if (randomizer < -1 || randomizer >= 1)
    		throw new GenerationException("invalid randomizer " + randomizer);

        new SafeContextFactory().makeContext();
        Context rhino = Context.enter();

		// it's set because of the problem:
		// Encountered code generation error while compiling script: generated bytecode for method exceeds 64K limit.
        rhino.setOptimizationLevel(-1);

        try {
        	Scriptable scope = rhino.initStandardObjects();
			rhino.evaluateString(scope, generatorScript, "<generator>", 1, null);
			rhino.evaluateString(scope, pruneScript, "<prune>", 1, null);
			rhino.evaluateString(scope, jsfScript, "<jsf>", 1, null);

			Function generateFunction = (Function)scope.get("generateWithPruning", scope );
			//Function generateFunction = (Function)scope.get("changedSchema", scope );
			Object generateArgs[]= {  schema,  stage, minAppVer, mode.toString(), new Double(randomizer) };
			String sampleStr = (String)generateFunction.call(rhino, scope, scope, generateArgs);

			// transformation for pretty-printing & remove generated id
			JSONObject json = new JSONObject(sampleStr);
			json.remove(Constants.JSON_FIELD_GENERATED_ID);
			return json.write(true);
        }
        catch (Throwable e){
        	throw new GenerationException(e.getMessage());
        }
        finally {
        	Context.exit();
        }
	}

	public static String gtest(String func, String generatorScript, String jsfScript, String pruneScript,
			String schema, String stage, String minAppVer, InputSampleGenerationMode mode, double randomizer) throws GenerationException
	{
    	if (randomizer < -1 || randomizer >= 1)
    		throw new GenerationException("invalid randomizer " + randomizer);

        new SafeContextFactory().makeContext();
        Context rhino = Context.enter();
        rhino.setOptimizationLevel(-1);

        try {
        	Scriptable scope = rhino.initStandardObjects();
			rhino.evaluateString(scope, generatorScript, "<generator>", 1, null);
			rhino.evaluateString(scope, pruneScript, "<prune>", 1, null);
			rhino.evaluateString(scope, jsfScript, "<jsf>", 1, null);

			Function generateFunction = (Function)scope.get(func, scope );
			Object generateArgs[]= {  schema,  stage, minAppVer, mode.toString(), new Double(randomizer) };
			String sampleStr = (String)generateFunction.call(rhino, scope, scope, generateArgs);

			JSONObject json = new JSONObject(sampleStr);
			json.remove(Constants.JSON_FIELD_GENERATED_ID);
			return json.write(true);
        }
        catch (Throwable e){
        	throw new GenerationException(e.getMessage());
        }
        finally {
        	Context.exit();
        }
	}


    //------------------------------------------------------------
	// (backward compatibility method, uses MAXIMAL mode and true randomization)
	public static String generation(String generatorScript, String jsfScript, String pruneScript,
			String schema, String stage, String minAppVer) throws GenerationException
	{
		return generation(generatorScript, jsfScript, pruneScript,schema, stage, minAppVer, InputSampleGenerationMode.MAXIMAL, -1);
	}

    //------------------------------------------------------------
	// for debugging: return the pruned schema
	public static String pruneSchema(String prune, String schema, String stage, String minAppVersion) throws ValidationException
	{
		new SafeContextFactory().makeContext();
		Context rhino = Context.enter();

		try {
			// ScriptableObject scope = new Global(rhino); // use this if you need the print(...) function

			ScriptableObject scope = rhino.initStandardObjects();
			rhino.evaluateString(scope, prune, "<prune>", 1, null);

			Function pruneFunction = (Function)scope.get("pruneOneSchema", scope);
			Object args[]= {  schema,  stage, minAppVersion};
			return (String) pruneFunction.call(rhino, scope, scope, args);
		}
		catch (Exception e)
		{
			throw new ValidationException(e.getMessage());
		}
		finally {
			Context.exit();
		}    	
	}

	//------------------------------------------------------------
	public static Map<String,String> getStageForAllFields(String generatorScript, String jsfScript,
			String pruneScript, String schema) throws GenerationException, JSONException
	{
		double randomizer = 0.5;
		String minAppVer = "99999999"; // take all versions
		InputSampleGenerationMode mode = InputSampleGenerationMode.MAXIMAL;

		String prod = generation(generatorScript, jsfScript, pruneScript, schema, "PRODUCTION",  minAppVer, mode, randomizer);
		String dvp =  generation(generatorScript, jsfScript, pruneScript, schema, "DEVELOPMENT", minAppVer, mode, randomizer);

		TreeSet<String> prodSet = new TreeSet<String>();
		TreeSet<String> dvpSet =  new TreeSet<String>();
		Utilities.flatten(new JSONObject(prod), null, prodSet, null);
		Utilities.flatten(new JSONObject(dvp),  null, dvpSet, null);

		TreeMap<String,String> out = new TreeMap<String,String>();
		for (String key : dvpSet)
		{
			String stage = prodSet.contains(key) ? "PRODUCTION" : "DEVELOPMENT";
			out.put(key, stage);
		}

		return out;
	}
}
